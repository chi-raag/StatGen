---
title: "Lecture 05: GWAS in R"
subtitle: PUBH 8878, Statistical Genetics
format: 
    revealjs:
        theme: [default, "custom.scss"]
        slide-number: true
        html-math-method: katex
execute:
    echo: TRUE
engine: knitr
bibliography: references.bib
csl: https://www.zotero.org/styles/bioinformatics
draft: true
---

## Step 1: Setup

```{r, echo=T, label="libraries", message = F}
library(SNPRelate) # <1>
library(GENESIS) # <2>
library(GWASTools) # <3>
library(qqman) # <4>
library(data.table) # <5>
library(ggplot2)
library(dplyr)
set.seed(8878)
```

1.  SNPRelate (Zheng et al., 2012) for GDS file handling and genotype data management
2.  GENESIS for genome-wide association analysis and relatedness estimation
3.  GWASTools for genotype data management and quality control
4.  qqman for creating Q-Q and Manhattan plots
5.  data.table for efficient data manipulation

## Step 1: Setup & data access

```{r, eval = FALSE}
#| code-line-numbers: "1"
gdsfile <- system.file("extdata", "HapMap_ASW_MXL_geno.gds", package = "GENESIS") # <1>

g <- SNPRelate::snpgdsOpen(gdsfile)

samp.id <- read.gdsn(index.gdsn(g, "sample.id"))
snp.id <- read.gdsn(index.gdsn(g, "snp.id"))
chr <- read.gdsn(index.gdsn(g, "snp.chromosome"))
pos <- read.gdsn(index.gdsn(g, "snp.position"))
```

1.  Locate the example GDS file included with the GENESIS package

## Step 1: Setup & data access

```{r, eval = FALSE}
#| code-line-numbers: "1-3"
gdsfile <- system.file("extdata", "HapMap_ASW_MXL_geno.gds", package = "GENESIS") # <1>

g <- SNPRelate::snpgdsOpen(gdsfile) # <2>

samp.id <- read.gdsn(index.gdsn(g, "sample.id"))
snp.id <- read.gdsn(index.gdsn(g, "snp.id"))
chr <- read.gdsn(index.gdsn(g, "snp.chromosome"))
pos <- read.gdsn(index.gdsn(g, "snp.position"))
```

1.  Locate the example GDS file included with the GENESIS package
2.  Open the GDS file for random access to genotype data

## Step 1: Setup & data access

```{r}
gdsfile <- system.file("extdata", "HapMap_ASW_MXL_geno.gds", package = "GENESIS") # <1>

g <- SNPRelate::snpgdsOpen(gdsfile) # <2>

samp.id <- read.gdsn(index.gdsn(g, "sample.id")) # <3>
snp.id <- read.gdsn(index.gdsn(g, "snp.id")) # <3>
chr <- read.gdsn(index.gdsn(g, "snp.chromosome")) # <3>
pos <- read.gdsn(index.gdsn(g, "snp.position")) # <3>
```

1.  Locate the example GDS file included with the GENESIS package
2.  Open the GDS file for random access to genotype data
3.  Read sample IDs, SNP IDs, chromosome numbers, and positions from the GDS file

# Step 2: Pre-imputation Quality Control (QC) & filtering

## Genotype quality control

1.  Filtering for minor allele frequency
2.  Filtering SNPs based on violation of HWE

## Filtering for minor allele frequency (MAF)

-   SNP-chips often determine genotypes based on intensities for each allele
-   When MAF is low, genotype clusters can overlap, leading to genotyping errors

```{r, echo = F}
set.seed(2025)

simulate_genotype_df <- function(
    N,
    maf,
    sample_genotypes = TRUE,
    centers = list(
        AA = c(allele1 = 1.8, allele2 = 0.2),
        AB = c(allele1 = 1.0, allele2 = 1.0),
        BB = c(allele1 = 0.2, allele2 = 1.8)
    ),
    sd_range = c(min = 0.08, max = 0.35),
    sd_factors = c(AA = 0.9, AB = 1.0, BB = 0.9),
    spread_fn = NULL) {
    stopifnot(N > 0, maf > 0, maf <= 0.5)
    stopifnot(is.logical(sample_genotypes), length(sample_genotypes) == 1)
    stopifnot(length(sd_range) == 2, all(sd_range > 0), sd_range[2] >= sd_range[1])

    required_genotypes <- c("AA", "AB", "BB")
    stopifnot(all(required_genotypes %in% names(centers)))
    sd_factors <- unlist(sd_factors, use.names = TRUE)
    stopifnot(all(required_genotypes %in% names(sd_factors)))
    sd_factors <- sd_factors[required_genotypes]
    stopifnot(all(sd_factors > 0))

    probs <- c((1 - maf)^2, 2 * maf * (1 - maf), maf^2)
    if (isTRUE(sample_genotypes)) {
        counts <- as.vector(rmultinom(1, size = N, prob = probs))
    } else {
        expected <- probs * N
        counts <- floor(expected)
        remainder <- N - sum(counts)
        if (remainder > 0) {
            frac <- expected - counts
            order_idx <- order(frac, decreasing = TRUE)
            counts[order_idx[seq_len(remainder)]] <- counts[order_idx[seq_len(remainder)]] + 1
        }
    }
    names(counts) <- required_genotypes

    if (!is.null(spread_fn)) {
        stopifnot(is.function(spread_fn))
        spread <- spread_fn(maf, sd_range)
    } else {
        spread <- sd_range[1] + (sd_range[2] - sd_range[1]) * (0.5 - maf) / 0.5
    }
    stopifnot(is.numeric(spread), length(spread) == 1)
    spread <- max(sd_range[1], min(sd_range[2], spread))

    draw_cluster <- function(n, means, sd_scale) {
        data.frame(
            allele1 = rnorm(n, means["allele1"], sd_scale),
            allele2 = rnorm(n, means["allele2"], sd_scale)
        )
    }

    build_genotype_df <- function(genotype) {
        center <- centers[[genotype]]
        center <- unlist(center, use.names = TRUE)
        stopifnot(length(center) >= 2)
        if (is.null(names(center)) || !all(c("allele1", "allele2") %in% names(center))) {
            center <- center[seq_len(2)]
            names(center) <- c("allele1", "allele2")
        } else {
            center <- center[c("allele1", "allele2")]
        }
        cluster_sd <- spread * sd_factors[[genotype]]
        cluster_df <- draw_cluster(counts[genotype], center, cluster_sd)
        cluster_df$genotype <- genotype
        cluster_df
    }

    df <- do.call(rbind, lapply(required_genotypes, build_genotype_df))
    df$genotype <- factor(df$genotype, levels = required_genotypes)
    df
}

good_df <- simulate_genotype_df(
    N = 10000,
    maf = 0.40,
    sample_genotypes = TRUE
)

poor_df <- simulate_genotype_df(
    N = 10000,
    maf = 0.05,
    sample_genotypes = TRUE
)
```

## Filtering for minor allele frequency (MAF)

```{r, echo = FALSE}
p1 <- ggplot(good_df, aes(allele1, allele2, color = genotype)) +
    geom_point(alpha = 0.7, size = 1.5) +
    labs(
        title = "Well-separated genotype clusters",
        x = "Allele 1 intensity",
        y = "Allele 2 intensity",
        color = "Genotype"
    ) +
    coord_equal() +
    theme_minimal()

p2 <- ggplot(poor_df, aes(allele1, allele2, color = genotype)) +
    geom_point(alpha = 0.7, size = 1.5) +
    labs(
        title = "Poor separation (low MAF)",
        x = "Allele 1 intensity",
        y = "Allele 2 intensity",
        color = "Genotype"
    ) +
    coord_equal() +
    theme_minimal()

cowplot::plot_grid(p1, p2, ncol = 2)
```

## Filtering for minor allele frequency (MAF)

```{r, echo = T}
af <- snpgdsSNPRateFreq(g) # <1>
maf <- af$MinorFreq # <2>
miss_var <- af$MissingRate # <3>
```

1.  Compute allele frequencies and missing rates for all SNPs
2.  Extract minor allele frequencies (MAF)
3.  Extract variant missingness rates

## Filtering for minor allele frequency (MAF)

```{r, echo = F}
data.frame(maf = maf) |>
    mutate(maf_le05 = maf < 0.05) |>
    ggplot(aes(x = maf, fill = maf_le05)) +
    geom_histogram(binwidth = 0.01, color = "black") +
    geom_vline(xintercept = c(0.05), linetype = "dashed", color = "red") +
    theme_minimal() +
    viridis::scale_fill_viridis(discrete = TRUE, end = .9, begin = .2) +
    labs(fill = "MAF < .05")
```

## Variant missingness

-   Missingness can indicate genotyping errors or batch effects
-   Missingness can be non-random with respect to phenotype or ancestry
-   Typically filter variants with \>2% missingness

## Variant missingness

```{r, echo = F}
data.frame(miss_var = miss_var) |>
    mutate(miss_var_gt02 = miss_var > 0.02) |>
    ggplot(aes(x = miss_var, fill = miss_var_gt02)) +
    geom_histogram(binwidth = 0.01, color = "black") +
    geom_vline(xintercept = c(0.02), linetype = "dashed", color = "red") +
    theme_minimal() +
    viridis::scale_fill_viridis(discrete = TRUE, end = .9, begin = .2) +
    labs(fill = "Missing > .02")
```

## Filtering SNPs based on violation of HWE

-   Deviations (rejections of $H_0$) can indicate genotyping errors, population structure, or selection
-   Typically tested in controls or unrelateds for case-control studies

## Filtering SNPs based on violation of HWE

```{r hwe-code, echo = T}
hwe_p <- snpgdsHWE(g, snp.id = snp.id)
```

```{r hwe-plot, echo = F}
ggplot(data.frame(hwe_p = hwe_p), aes(x = hwe_p)) +
    geom_histogram(binwidth = 0.01) +
    geom_vline(xintercept = c(1e-6), linetype = "dashed", color = "red") +
    theme_minimal()
```

## Sample-level missingness & heterozygosity

-   Samples with high missingness may have poor DNA quality or technical issues
-   Samples with extreme heterozygosity rates may be contaminated or mislabelled

## Sample-level missingness & heterozygosity

```{r, echo = T}
samp_miss <- snpgdsSampMissRate(g)

G <- snpgdsGetGeno(g, with.id = TRUE)
geno_mat <- G$genotype
geno_mat[geno_mat == 3] <- NA_integer_  # SNPRelate encodes missing genotypes as 3
het_rate <- colMeans(geno_mat == 1, na.rm = TRUE)
```

## Sample-level missingness & heterozygosity

```{r, echo = F}
p1 <- data.frame(samp_miss = samp_miss) |>
    mutate(samp_outlier = samp_miss > 0.02) |>
    ggplot(aes(x = samp_miss, fill = samp_outlier)) +
    geom_histogram(binwidth = 0.01, color = "black") +
    geom_vline(xintercept = c(0.02), linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Sample missingness", x = "Missing rate")

p2 <- data.frame(het_rate = het_rate) |>
    mutate(het_outlier = abs(scale(het_rate)) > 3) |>
    ggplot(aes(x = het_rate, fill = het_outlier)) +
    geom_histogram(binwidth = 0.01, color = "black") +
    geom_vline(xintercept = c(mean(het_rate) + 3 * sd(het_rate),
                              mean(het_rate) - 3 * sd(het_rate)),
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Heterozygosity rate", x = "Heterozygosity rate")

cowplot::plot_grid(p1, p2, ncol = 2)
```

## Thresholding

```{r}
thr_samp_miss <- 0.02
thr_var_miss <- 0.02
thr_maf <- 0.01
thr_hwe <- 1e-6
thr_het_z <- 3

keep_sample <- which(samp_miss <= thr_samp_miss & abs(scale(het_rate)) < thr_het_z)
keep_snp <- which(miss_var <= thr_var_miss & maf >= thr_maf & (is.na(hwe_p) | hwe_p > thr_hwe))

samp.keep.id <- samp.id[keep_sample]
snp.keep.id <- snp.id[keep_snp]
```

## SNP correlation structure

-   Inspect pairwise SNP correlations (LD) among variants that pass the basic filters before pruning.\
-   When many SNPs remain, plot the first few hundred to keep the heatmap interpretable.

## SNP correlation structure

```{r, warning=FALSE, message=FALSE}
max_plot_snps <- 100
ld_snp_ids <- if (length(snp.keep.id) > max_plot_snps) {
    snp.keep.id[seq_len(max_plot_snps)]
} else {
    snp.keep.id
}

ld_mat <- snpgdsLDMat(
    g,
    sample.id = samp.keep.id,
    snp.id = ld_snp_ids,
    slide = -1,
    method = "corr"
)

ld_vals <- ld_mat$LD
dimnames(ld_vals) <- list(ld_snp_ids, ld_snp_ids)

ld_long <- as.data.frame(as.table(ld_vals))
colnames(ld_long) <- c("snp_i", "snp_j", "corr")

ggplot(ld_long, aes(x = snp_i, y = snp_j, fill = corr)) +
    geom_tile() +
    coord_equal() +
    scale_fill_gradient2(
        low = "#313695", mid = "#ffffbf", high = "#a50026",
        limits = c(-1, 1), midpoint = 0, oob = scales::squish
    ) +
    theme_minimal() +
    theme(
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank()
    ) +
    labs(
        title = sprintf("Pairwise SNP correlation (first %d passing variants)", length(ld_snp_ids)),
        x = "SNP1",
        y = "SNP2",
        fill = "r"
    )
```

## LD pruning

1.  Randomly select a starting position i (‘start.pos="random"’), i=1 if ‘start.pos="first"’, or i=last if ‘start.pos="last"’; and let the current SNP set S={ i };
2.  For each right position j from i+1 to n: if any LD between j and k is greater than ‘ld.threshold’, where k belongs to S, and both of j and k are in the sliding window, then skip j; otherwise, let S be S + { j };
3.  For each left position j from i-1 to 1: if any LD between j and k is greater than ‘ld.threshold’, where k belongs to S, and both of j and k are in the sliding window, then skip j; otherwise, let S be S + { j };
4.  Output S, the final selection of SNPs.

## LD pruning

```{r, label="ld_code"}
set.seed(1)
ld_prune <- snpgdsLDpruning(g,
    sample.id = samp.keep.id, 
    snp.id = snp.keep.id,
    method = "r",
    ld.threshold = sqrt(.1),  
    autosome.only = TRUE
)
snps_pruned <- unlist(ld_prune, use.names = FALSE)
```

## Relatedness

-   We need to account for relatedness to avoid confounding in PCA and association testing
-   KING (Kinship-based INference for GWAS) is method for estimating pairwise kinship robust to population structure ([@manichaikulRobustRelationshipInference2010]

## Relatedness

```{r, label="king_code", echo = T}
king <- snpgdsIBDKING(g, # <1>
                      sample.id = samp.keep.id,  # <1>
                      snp.id = snps_pruned,  # <1>
                      type = "KING-robust") # <1>

KINGmat <- GENESIS::kingToMatrix(king) # <2>
```

1. Run KING on our dataset with the filtered samples and SNPs
2. Convert into a kinship matrix we can use for downstream tasks

## Estimated family clusters

-   Build a kinship graph using a threshold (default: 3rd-degree or closer).
-   Connected components approximate families/households; singletons have no relatives above the threshold.

```{r kin-clusters, eval = F}
kinship_threshold <- 0.0625

king_adj <- KINGmat
diag(king_adj) <- 0
king_adj[king_adj < kinship_threshold] <- 0

family_graph <- igraph::graph_from_adjacency_matrix(king_adj, mode = "undirected", weighted = TRUE, diag = FALSE)
comp <- igraph::components(family_graph)

family_map <- tibble::tibble(
    scanID = names(comp$membership),
    family_id = paste0("fam_", sprintf("%03d", comp$membership))
)

family_summary <- family_map |>
    dplyr::group_by(family_id) |>
    dplyr::summarise(
        n_members = dplyr::n(),
        members = paste(scanID, collapse = ", "),
        .groups = "drop"
    ) |>
    dplyr::arrange(dplyr::desc(n_members), family_id)

head(family_summary, 5) |>
    knitr::kable(col.names = c("Family", "n", "Sample IDs"))
```

## Estimated family clusters

```{r kin-clusters, echo = F}
```

## Ancestry PCs

-   So we have our kinship matrix
-   We now want ancestry PCs for covariates
-   **PC‑AiR** (Conomos et al., 2015) computes PCs on unrelateds, then projects onto relateds
-   Relateds are identified using the KING kinship matrix

## Ancestry PCs

```{r, label="pcair_code", output="false"}
snpgdsClose(g) # <1>
geno_reader <- GWASTools::GdsGenotypeReader(gdsfile) # <2>
geno_data <- GenotypeData(geno_reader) # <3>
pcair_out <- pcair(geno_data, # <4>
                   kinobj = KINGmat, # <4>
                   divobj = KINGmat, # <4>
                   snp.include = snps_pruned, # <4>
                   sample.include = samp.keep.id) # <4> 
```

1. We need to close the SNPRelate connection before opening with GWASTools
2. Open the GDS file with GWASTools
3. Create a GenotypeData object for analysis
4. Run PC-AiR using the KING kinship matrix to identify unrelateds and compute PCs

## Ancestry PCs

```{r, echo=FALSE}
plot(pcair_out)
```

## Ancestry PCs

```{r, echo=FALSE, eval = T}
K <- pcair_out$kinship
hist(K[upper.tri(K)], main = "PC-Relate kinship (off-diagonal)", xlab = "kinship")
```


## Step 6 — Phenotype & covariates (code)

```{r, label="pheno_code", eval=FALSE}
# Simulate simple covariates
set.seed(99)
N <- nrow(pcs)
sex <- sample(c("M", "F"), N, replace = TRUE)
age <- round(rnorm(N, 50, 10))

# Choose one moderately frequent SNP and simulate a quantitative trait with a planted effect
maf_full <- maf
ix <- which(!is.na(maf_full) & maf_full > 0.2 & maf_full < 0.3)[1]

G1 <- GWASTools::getGenotypeSelection(geno, snpID = snp.id[ix], scanID = samp.keep.id)
G1 <- as.numeric(G1) # 0,1,2 with NAs
G1[is.na(G1)] <- mean(G1, na.rm = TRUE) # quick mean-impute for demo

y <- as.numeric(0.30 * scale(G1) + 0.02 * scale(age) + 0.05 * (sex == "M") + rnorm(N))

# Assemble scan annotation with covariates and PCs
scanDF <- data.frame(scanID = samp.keep.id, y = y, age = age, sex = sex, pcs[, 1:4])
colnames(scanDF)[6:9] <- paste0("PC", 1:4)
scanAnnot2 <- GWASTools::ScanAnnotationDataFrame(scanDF)
# Update 'geno' to carry covariates
GWASTools::close(geno)
geno <- GWASTools::GenotypeData(GWASTools::GdsGenotypeReader(gdsfile), scanAnnot = scanAnnot2)
```

------------------------------------------------------------------------

## Step 6 — Phenotype & covariates (explain)

**Why simulate?**\
HapMap doesn’t ship with rich traits. We plant a small genotype effect so that the mixed‑model GWAS produces a recognizable signal.

**Model intent** - Covariates: `age`, `sex`, `PC1–PC4` (ancestry).\
- Genetic effect: \~0.30 SD per minor allele on a standardized SNP.

**Deliverable** - `geno` now contains sample annotations with (y, X), and PCs.

------------------------------------------------------------------------

## Step 6 — Phenotype & covariates (output)

```{r, ref.label="pheno_code", echo=FALSE, eval = F}
```

```{r, echo=FALSE, eval = F}
head(data.frame(scanID = scanDF$scanID, y = round(scanDF$y, 3), age = scanDF$age, sex = scanDF$sex))
```

------------------------------------------------------------------------

## Step 7 — Null model (LMM) (code)

```{r, label="null_code", eval=FALSE}
nullmod <- GENESIS::fitNullModel(scanAnnot2,
    outcome = "y",
    covars = c("age", "sex", "PC1", "PC2", "PC3", "PC4"),
    cov.mat = K, family = "gaussian"
)

# Genotype iterator (block-wise scan of all SNPs kept by QC)
it <- GWASTools::GenotypeBlockIterator(geno, snpInclude = snp.keep.id, snpBlock = 5000)
```

------------------------------------------------------------------------

## Step 7 — Null model (explain)

**LMM**\
\[ y = X\beta + \gamma G + u + \varepsilon,\quad u \sim \mathcal{N}(0,\sigma\_g\^2 K),\quad \varepsilon \sim \mathcal{N}(0,\sigma\_e\^2 I). \]

-   We fit variance components under (H_0:\gamma=0) (the **null model**) once.\
-   Association uses a **Score test**, reusing the null for each SNP.\
-   PCs adjust for residual structure; (K) captures realized relatedness.

**Deliverables** - `nullmod`: object with (\hat\sigma\_g\^2,\hat\sigma\_e\^2), fixed effects, and residuals.\
- `it`: a block iterator to stream SNPs without loading them all at once.

------------------------------------------------------------------------

## Step 7 — Null model (output)

```{r, ref.label="null_code", echo=FALSE, eval = F}
```

```{r, echo=FALSE, eval = F}
nullmod$varComp
```

------------------------------------------------------------------------

## Step 8 — Association testing (code)

```{r, label="assoc_code", eval=FALSE}
assoc <- GENESIS::assocTestSingle(it, null.model = nullmod, test = "Score")
# Prepare results for plotting
res <- data.frame(
    SNP = assoc$snpID,
    CHR = as.integer(assoc$chr),
    BP = assoc$pos,
    P = assoc$Score.pval,
    BETA = assoc$Est,
    SE = assoc$Est.SE
)
# Genomic control
lambda_gc <- median(stats::qchisq(1 - res$P, df = 1), na.rm = TRUE) / 0.456
```

------------------------------------------------------------------------

## Step 8 — Association testing (explain)

-   **Score test**: efficient per‑SNP test using derivatives at the null; numerically stable at scale.\
-   With our simulated effect, we expect one clear peak near the planted SNP, modest elsewhere.\
-   **Calibration**: ( \lambda\_{GC} ) near 1 indicates good control; large values suggest stratification, relatedness, or batch effects.

**Deliverables** - `res`: per‑SNP estimates and p‑values.\
- `lambda_gc`: quick inflation diagnostic.

------------------------------------------------------------------------

## Step 8 — Association testing (output)

```{r, ref.label="assoc_code", echo=FALSE, eval = F}
```

```{r, echo=FALSE, eval = F}
lambda_gc
head(res[order(res$P), c("SNP", "CHR", "BP", "BETA", "SE", "P")], 10)
```

------------------------------------------------------------------------

## Step 9 — Figures: Manhattan & QQ (code)

```{r, label="plots_code", eval=FALSE}
library(qqman)
# Clean CHR for qqman (drop non-autosomes for the plot)
plotdat <- subset(res, CHR %in% 1:22 & is.finite(P))
manhattan(plotdat,
    chr = "CHR", bp = "BP", p = "P", snp = "SNP",
    suggestiveline = -log10(1e-5), genomewideline = -log10(5e-8),
    main = "GWAS (LMM) — Manhattan"
)
qq(plotdat$P, main = "QQ plot")
```

------------------------------------------------------------------------

## Step 9 — Figures: Manhattan & QQ (explain)

**How to read the plots** - **Manhattan**: look for peaks spanning multiple SNPs in LD; single‑SNP spikes can be artifacts.\
- **QQ**: early alignment with the diagonal + tail deviation at top hits is typical of a polygenic trait.\
- Show ( \lambda\_{GC} ) on the figure or caption.

**Caveats** - Our dataset is **small** and **simulated**; the figures illustrate **method behavior**, not discovery.

------------------------------------------------------------------------

## Step 9 — Figures: Manhattan & QQ (output)

```{r, ref.label="plots_code", echo=FALSE, eval = F}
```

------------------------------------------------------------------------

## (Optional) Step 10 — Binary trait & SPA (code)

```{r, label="spa_code", eval=FALSE}
# Simulate a low-prevalence binary trait using the same planted SNP
logit_p <- -2.3 + 0.8 * scale(G1) + 0.1 * scale(age) + 0.1 * (sex == "M") + as.numeric(pcs[, 1]) * 0.0
p_case <- plogis(logit_p)
case <- rbinom(length(p_case), 1, p_case)

scanDF2 <- data.frame(scanID = samp.keep.id, case = case, age = age, sex = sex, pcs[, 1:4])
colnames(scanDF2)[4:7] <- paste0("PC", 1:4)
scanAnnot3 <- GWASTools::ScanAnnotationDataFrame(scanDF2)

null_cc <- GENESIS::fitNullModel(scanAnnot3,
    outcome = "case",
    covars = c("age", "sex", "PC1", "PC2", "PC3", "PC4"),
    cov.mat = K, family = "binomial"
)

it2 <- GWASTools::GenotypeBlockIterator(geno, snpInclude = snp.keep.id, snpBlock = 5000)
assoc_cc <- GENESIS::assocTestSingle(it2, null.model = null_cc, test = "Score.SPA")
```

------------------------------------------------------------------------

## (Optional) Step 10 — Binary trait & SPA (explain)

-   Severe **case:control imbalance** and low MAC inflate type‑I error for naive tests.\
-   **SPA (saddlepoint approximation)** yields accurate p‑values in the tails by correcting score distributions.\
-   `assocTestSingle(..., test="Score.SPA")` invokes SPA within GENESIS.

------------------------------------------------------------------------

## Wrap‑up & what to record

```{r, echo = T}
GWASTools::close(geno_reader)
```

-   **Parameters**: thresholds (QC), LD‑prune settings, PCs used, null model family, random effect (K), LOCO (used? no).\
-   **Software**: package versions; genome build; random seeds.\
-   **Deliverables**: annotated code, QQ/Manhattan, top hits table, (\lambda\_{GC}).

**Homework (separate)**\
Install PLINK and reproduce QC + PCs on a small chr22 dataset; compare with R results.
